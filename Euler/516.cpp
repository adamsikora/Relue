#include <iostream>
#include <iomanip>

#include <fstream>

#include <sstream>

#include <memory>
#include <assert.h>
#include <cstddef>

#include <limits>

#include <set>
#include <unordered_set>
#include <map>
#include <unordered_map>
#include <vector>
#include <list>

#include <math.h>

//#include <boost/circular_buffer.hpp>
//#include <boost/lexical_cast.hpp>
//#include <boost/functional/hash.hpp>
//#include <boost/rational.hpp>
#include <boost\multiprecision\cpp_int.hpp>

#include "ttmath/ttmath.h"

#include "mtrand.h"

#include "primes.h"
#include "Clipboard.h"
#include "Palindrome.h"

#include "StopWatch.h"

struct pairhash {
public:
	template <typename T, typename U>
	std::size_t operator()(const std::pair<T, U> &x) const
	{
		return std::hash<T>()(x.first) ^ std::hash<U>()(x.second);
	}
};

const uint64_t thousand = 1000;
const uint64_t million = thousand * thousand;
const uint64_t billion = thousand * million;
const uint64_t trillion = million * million;
const uint64_t quadrillion = million * billion;

boost::multiprecision::cpp_int finalSum = 0;

const uint64_t modulo = 1i64 << 32i64;
const uint64_t threshold = million*million;

StopWatch sw;

std::vector<int64_t> factors;

boost::multiprecision::cpp_int recurse(boost::multiprecision::cpp_int current, int64_t index, int64_t threshold)
{
	if (index < factors.size()) {
		boost::multiprecision::cpp_int next = current*factors[index];
		if (next <= threshold) {
			return (recurse(current, index + 1, threshold) % modulo + next % modulo + recurse(next, index + 1, threshold) % modulo) % modulo;
		}
	}
	return 0;
}

boost::multiprecision::cpp_int find(int64_t threshold)
{
	boost::multiprecision::cpp_int result = 0;

	for (int64_t i = 1; i <= threshold; i *= 2) {
		for (int64_t j = 1; i*j <= threshold; j *= 3) {
			for (int64_t k = 1; i*j*k <= threshold; k *= 5) {
				result += i*j*k;
				result %= modulo;
				result += recurse(i*j*k, 0, threshold);
				result %= modulo;
			}
		}
	}
	return result;
}

int main()
{
	sw.start();
	/* obtained from mathematica
	threshold = 10^12;
	S[max_] := {
	  primes := {};
	  For[pow2 = 1, pow2 < max, pow2 *= 2,
	   For[pow3 = 1, pow2*pow3 < max, pow3 *= 3,
	    For[pow5 = 1, pow2*pow3*pow5 < max, pow5 *= 5,
	     If[PrimeQ[pow2*pow3*pow5 + 1], 
	      AppendTo[primes, pow2*pow3*pow5 + 1]]
	     ]
	    ]
	   ];
	  primes = Sort[primes];
	  primes = Delete[primes, 1];
	  primes = Delete[primes, 1];
	  primes = Delete[primes, 1];
	  primes
	  }
	Timing[S[threshold]]
	*/

	//factors = { 7i64, 11i64, 13i64, 17i64, 19i64, 31i64, 37i64, 41i64, 61i64, 73i64, 97i64 };
	factors = {
		7i64, 11i64, 13i64, 17i64, 19i64, 31i64, 37i64, 41i64, 61i64, 73i64, 97i64, 101i64, 109i64, 151i64, 163i64, 181i64,
		193i64, 241i64, 251i64, 257i64, 271i64, 401i64, 433i64, 487i64, 541i64, 577i64, 601i64, 641i64, 751i64, 769i64,
		811i64, 1153i64, 1201i64, 1297i64, 1459i64, 1601i64, 1621i64, 1801i64, 2161i64, 2251i64, 2593i64,
		2917i64, 3001i64, 3457i64, 3889i64, 4001i64, 4051i64, 4801i64, 4861i64, 6481i64, 7681i64, 8101i64,
		8641i64, 9001i64, 9601i64, 9721i64, 10369i64, 11251i64, 12289i64, 14401i64, 15361i64, 16001i64,
		17497i64, 18433i64, 19441i64, 21601i64, 21871i64, 22501i64, 23041i64, 24001i64, 25601i64, 32401i64,
		33751i64, 36451i64, 37501i64, 39367i64, 40961i64, 43201i64, 52489i64, 54001i64, 57601i64, 58321i64,
		61441i64, 62501i64, 65537i64, 72901i64, 76801i64, 77761i64, 81001i64, 87481i64, 90001i64, 96001i64,
		103681i64, 112501i64, 115201i64, 121501i64, 131221i64, 138241i64, 139969i64, 147457i64,
		150001i64, 155521i64, 160001i64, 163841i64, 172801i64, 180001i64, 184321i64, 196831i64,
		209953i64, 259201i64, 270001i64, 281251i64, 307201i64, 311041i64, 328051i64, 331777i64,
		345601i64, 384001i64, 405001i64, 414721i64, 432001i64, 437401i64, 450001i64, 466561i64,
		472393i64, 506251i64, 562501i64, 576001i64, 629857i64, 737281i64, 746497i64, 786433i64,
		839809i64, 900001i64, 921601i64, 937501i64, 972001i64, 995329i64, 1125001i64, 1166401i64,
		1179649i64, 1350001i64, 1492993i64, 1620001i64, 1769473i64, 1822501i64, 1843201i64,
		1920001i64, 1968301i64, 1990657i64, 2073601i64, 2099521i64, 2160001i64, 2400001i64,
		2654209i64, 2799361i64, 3037501i64, 3072001i64, 3456001i64, 3600001i64, 3686401i64,
		3750001i64, 4218751i64, 4374001i64, 4423681i64, 4723921i64, 5038849i64, 5184001i64,
		5308417i64, 5314411i64, 5400001i64, 5904901i64, 6144001i64, 6561001i64, 6635521i64,
		6750001i64, 6998401i64, 7290001i64, 8201251i64, 8503057i64, 8640001i64, 8748001i64,
		9375001i64, 10125001i64, 10497601i64, 11059201i64, 11337409i64, 12150001i64, 12441601i64,
		12597121i64, 12656251i64, 13122001i64, 13668751i64, 14155777i64, 15552001i64, 16384001i64,
		16588801i64, 16796161i64, 17496001i64, 17714701i64, 18750001i64, 19131877i64, 20995201i64,
		21600001i64, 22118401i64, 24000001i64, 24576001i64, 25312501i64, 26214401i64, 27993601i64,
		28125001i64, 28311553i64, 28800001i64, 29524501i64, 30000001i64, 30375001i64, 31492801i64,
		33177601i64, 35389441i64, 40960001i64, 41990401i64, 48600001i64, 49152001i64, 54675001i64,
		55987201i64, 57395629i64, 62500001i64, 63700993i64, 65610001i64, 71663617i64, 73811251i64,
		76800001i64, 81000001i64, 82012501i64, 83980801i64, 86093443i64, 88573501i64, 92160001i64,
		93312001i64, 99532801i64, 101250001i64, 102036673i64, 104857601i64, 105468751i64,
		113246209i64, 113906251i64, 117964801i64, 120932353i64, 124416001i64, 129600001i64,
		132710401i64, 141557761i64, 144000001i64, 145800001i64, 149299201i64, 150000001i64,
		162000001i64, 167772161i64, 169869313i64, 170061121i64, 175781251i64, 177147001i64,
		179159041i64, 189843751i64, 212576401i64, 226748161i64, 238878721i64, 245760001i64,
		253125001i64, 256000001i64, 258280327i64, 265420801i64, 265720501i64, 273375001i64,
		281250001i64, 288000001i64, 307200001i64, 331776001i64, 377487361i64, 409600001i64,
		410062501i64, 414720001i64, 432000001i64, 460800001i64, 466560001i64, 468750001i64,
		478296901i64, 483729409i64, 573956281i64, 600000001i64, 614400001i64, 615093751i64,
		637009921i64, 637729201i64, 655360001i64, 725594113i64, 746496001i64, 754974721i64,
		786432001i64, 860934421i64, 864000001i64, 874800001i64, 885735001i64, 937500001i64,
		943718401i64, 956593801i64, 984150001i64, 1036800001i64, 1049760001i64, 1088391169i64,
		1119744001i64, 1125000001i64, 1133740801i64, 1194393601i64, 1399680001i64,
		1415577601i64, 1492992001i64, 1500000001i64, 1536000001i64, 1572864001i64,
		1749600001i64, 1811939329i64, 1843200001i64, 1889568001i64, 2013265921i64,
		2187000001i64, 2239488001i64, 2304000001i64, 2361960001i64, 2441406251i64,
		2500000001i64, 2519424001i64, 2717908993i64, 2869781401i64, 2916000001i64,
		2949120001i64, 2952450001i64, 3110400001i64, 3164062501i64, 3221225473i64,
		3224862721i64, 3280500001i64, 3439853569i64, 3587226751i64, 3645000001i64,
		3796875001i64, 3874204891i64, 3936600001i64, 4050000001i64, 4076863489i64,
		4194304001i64, 4218750001i64, 4687500001i64, 4782969001i64, 4915200001i64,
		5125781251i64, 5165606521i64, 5273437501i64, 5535843751i64, 5898240001i64,
		6000000001i64, 6298560001i64, 6561000001i64, 6802444801i64, 6834375001i64,
		6879707137i64, 6912000001i64, 7962624001i64, 8162933761i64, 8542968751i64,
		8789062501i64, 9000000001i64, 9331200001i64, 9375000001i64, 9447840001i64,
		9600000001i64, 10485760001i64, 10616832001i64, 10871635969i64, 11466178561i64,
		11609505793i64, 11664000001i64, 11943936001i64, 13183593751i64, 13604889601i64,
		13996800001i64, 14155776001i64, 14400000001i64, 14511882241i64, 14929920001i64,
		15305500801i64, 15496819561i64, 16384000001i64, 16875000001i64, 17006112001i64,
		17714700001i64, 17915904001i64, 18000000001i64, 18345885697i64, 18874368001i64,
		18984375001i64, 20384317441i64, 20407334401i64, 20503125001i64, 21523360501i64,
		22781250001i64, 22958251201i64, 23245229341i64, 23437500001i64, 23619600001i64,
		23914845001i64, 24159191041i64, 24300000001i64, 25165824001i64, 25312500001i64,
		26873856001i64, 28697814001i64, 29386561537i64, 30000000001i64, 30720000001i64,
		30754687501i64, 32285040751i64, 32651735041i64, 33215062501i64, 33973862401i64,
		34560000001i64, 36450000001i64, 36864000001i64, 38220595201i64, 39550781251i64,
		41472000001i64, 42515280001i64, 42998169601i64, 43945312501i64, 45298483201i64,
		45562500001i64, 47775744001i64, 47829690001i64, 48000000001i64, 48372940801i64,
		51840000001i64, 55099802881i64, 56953125001i64, 63700992001i64, 64497254401i64,
		66355200001i64, 69657034753i64, 69984000001i64, 74649600001i64, 75000000001i64,
		76441190401i64, 76800000001i64, 77309411329i64, 82012500001i64, 85030560001i64,
		85996339201i64, 87890625001i64, 88473600001i64, 91729428481i64, 94371840001i64,
		96855122251i64, 97656250001i64, 105468750001i64, 116095057921i64, 117964800001i64,
		122305904641i64, 123834728449i64, 129600000001i64, 132710400001i64, 137749507201i64,
		138240000001i64, 140625000001i64, 141717600001i64, 144955146241i64, 151875000001i64,
		153773437501i64, 154968195601i64, 163258675201i64, 165888000001i64, 169869312001i64,
		171992678401i64, 174339220051i64, 174960000001i64, 177147000001i64, 183458856961i64,
		187500000001i64, 191318760001i64, 194400000001i64, 206158430209i64, 209952000001i64,
		213574218751i64, 226492416001i64, 235929600001i64, 251048476873i64, 269042006251i64,
		276480000001i64, 289910292481i64, 292968750001i64, 294912000001i64, 306110016001i64,
		309586821121i64, 311040000001i64, 313810596091i64, 314928000001i64, 337500000001i64,
		344373768001i64, 347892350977i64, 384000000001i64, 390625000001i64, 402653184001i64,
		407686348801i64, 409600000001i64, 424673280001i64, 425152800001i64, 430467210001i64,
		447897600001i64, 461320312501i64, 464904586801i64, 466560000001i64, 474609375001i64,
		498225937501i64, 512578125001i64, 549316406251i64, 562500000001i64, 573308928001i64,
		576000000001i64, 580475289601i64, 619872782401i64, 679477248001i64, 711914062501i64,
		716636160001i64, 720000000001i64, 816293376001i64, 820125000001i64, 825564856321i64,
		829440000001i64, 836828256241i64, 864000000001i64, 871696100251i64, 880602513409i64,
		922640625001i64, 966367641601i64, 967458816001i64
	};

	std::vector<boost::multiprecision::cpp_int> calculated{ find(100) };
	std::vector<int64_t> rightResults{ 3728 };
	
	bool right = true;
	for (uint64_t i = 0; i < calculated.size(); ++i) {
		std::cout << calculated[i] % modulo << " = " << rightResults[i] % modulo << std::endl;
		if (calculated[i] % modulo != rightResults[i] % modulo) {
			right = false;
		}
	}

	sw.stop();
	std::cout << sw.getLastElapsed() << std::endl;

	if (right) {
		std::cout << "Tests passed successfully" << std::endl;
	} else {
		std::cout << "Tests failed" << std::endl;
	}

	sw.start();

	finalSum = find(threshold);

	sw.stop();
	std::cout << sw.getLastElapsed() << std::endl;

	std::stringstream answer;
	answer << finalSum;
	std::ofstream file;
	file.open("Euler.txt");
	file << answer.str();
	file.close();
	std::cout << "Answer is: " << answer.str() << std::endl;
	ClipboardIt(answer.str());
	std::cin.ignore();
	return EXIT_SUCCESS;
}